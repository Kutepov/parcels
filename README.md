**1. Основная информация**

Классы парсеров располагать в директории `common/components/services`, название класса - название источника + суффикс Service.

Класс парсера должен наследовать абстрактный класс `common\components\services\BaseService` и реализовывать интерфейс `ValidateTrackNumberInterface`.

Можно использовать регулярные выражения или, например, библиотеку https://github.com/paquettg/php-html-parser, либо что-то другое, что удобно.

Все запросы в асинхронных парсерах должны слаться методом `sendAsyncRequestWithProxy`, не в асинхронных - `getWithProxy()` или `postWithProxy()`

Трек-номера посылок для разных стран можно найти в файле `track-numbers.csv` в корне проекта.

---

**2. Интерфейсы**
В некоторых случаях парсер должен реализовать один или несколько дополнительных интерфейсов:

* `AsyncTrackingInterface` - для парсеров, которые не используют анти-капчу
* `BatchTrackInterface` - для парсеров, в источниках которых есть возможность отследить несколько трек-номеров за один запрос
* `CaptchaPreheatInterface` - для парсеров, в источниках которых есть ReCaptcha и ее нужно разгадывать через сервис анти-капчи
* `CountryRestrictionInterface` - для парсеров каких-то "местных" источников, где основная часть трафика из одной или нескольких стран
* `ExcludeTrackNumberInterface` - исключения для шаблонов трек-номеров, которые не подходят для источника
* `InternationalValidateTrackNumberInterface` - для источников, которые являются официальной почтой в стране
* `SlowServiceInterface` - для источников, который могут долго отвечать, 10+ секунд

Напиши мне, если понадобится реализовать один из интерфейсов и что-то будет непонятно.

---
**3. Асинхронные парсеры**

Если в источнике нет капчи (кроме Recaptcha), то реализуем интерфейс `AsyncTrackingInterface`.
Если есть ReCaptcha, то дополнительно реализуем интерфейс `CaptchaPreheatInterface`

Метод `track($trackNumber)` в этом случае должен выглядеть следующим образом:

```
public function track($trackNumber)
{
    return $this->trackAsync($trackNumber)->wait();
}
```
Пример реализации асинхронного парсера с рекапчей есть в `XpressbeesService`, без рекапчи тот же принцип. 

Запросов можно слать несколько, передав их в параметре `$callback` метода `sendAsyncRequestWithProxy`.

В общем, в методе `trackAsync()` должны быть только необходимые запросы и возвращать он должен `PromiseInterface` guzzle, а в методе `parseResponse()` -
разбор данных из последнего запроса и возврат результата.

---
**4. Результат парсинга**
Результатом работы парсера (метод `track()` в синхронно работающих парсерах, метод `parseResponse()` в асинхронных) должен быть объект класса `common\components\services\models\Parcel`,
в котором должно быть заполнено, как минимум, свойство `statuses`. Все свойства `Parcel` и `Status` описаны в комментарии внутри файла.
Если на странице отслеживания посылки есть какая-то дополнительная информация - ее тоже парсим, либо в имеющиеся свойства `Parcel`, либо, если подходящего
свойства нет - в свойство `extraInfo` (массив ключ => значение). Пример заполнения `extraInfo` есть в парсере `NacexService`

**5. Проверка работоспособности парсера**

`./yii parser-check Класс_Парсера Трек_Номер`

например:

`./yii parser-check WSHService NX069877870BR`

---
**5. Про капчу**

Про то, как найти ключ рекапчи, чтобы отправить его в сервис для разгадывания, можно почитать тут:
* https://anticaptcha.atlassian.net/wiki/spaces/API/pages/6029315
* https://anticaptcha.atlassian.net/wiki/spaces/API/pages/9666585/HTML

Разгадывание капчи производится с помощью стороннего сервиса, есть вспомогательный класс `common\components\AntiCaptcha\Client`, это обертка над api сервиса анти-капчи,
подробнее про разгадывание можно почитать тут:
* https://anticaptcha.atlassian.net/wiki/spaces/API/pages/4227074

пример работы с ним можно найти в парсере `XpressbeesService`

**6. Примеры парсеров**

* EkartLogisticsService
* NacexService
* WSHService
* XpressbeesService